### 基本概念
贪心算法指的是，在对问题求解的时候，总是做出在当前看来是最好的选择。也就是说，不从整体最优加以考虑，他所做的仅是在某种意义上的局部最优解。
  
贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到最优解，选择的贪心策略必须具有无后效性，即某个状态以后的过程不会影响之前的状态，只于当前状态有关。
所以对所采用的贪心策略一定要仔细分析是否满足无后效性。

### 贪心算法的基本思路
1.建立数学模型来描述问题
2.把求解的问题分为若干个子问题
3.把每一个问题求解，得到子问题的局部最优解
4.把子问题的解局部最优解合成原来解问题的一个解

### 贪心算法
贪心策略适用的场景：局部最优解策略能导致产生全局最优解。
实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。

### 贪心算法的实现框架
从问题得某一个初始解出发：
while (能朝给定得总目标前进一步){
    利用可行得决策，求出可行解的一个解元素
}
由所有解元素组成一个可行解。

### 贪心策略选择
因为用贪心算法只能**通过解局部最优的策略来达到全局最优解**，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。

### 设计要素：
1. 贪心法适用于组合优化, 规模性的问题。
2.求解过程事多步判断过程，最终的判断序列对应于问题的最优解。
3.依据某种'短视的'贪心选择性质判断，性质好坏决定算法的成败。
4.贪心法必须进行正确性证明
5.证明贪心法不正确的技巧： 举反例

**证明方法：第一数学归纳法、第二数学归纳法**

### 例题分析
**【绳子截取】**

给你一个长度为n的绳子，请把绳子剪成m段（m，n都是整数，且都大于1）每段绳子的长度即为K[0],K[1],K[2]...K[m]。请问K[0]*k[1]..*k[m]可能的最大乘积是多少？

思路： 如果一个值可以被分成两份，并且这两份乘积大于这个值，就把他分成两份。

> x  1  2  3  4    5    6   7      ...
> y  1  2  3  2*2  2*3  3*3  3*2*2  ...

最终只剩下 2 和 3, 又 2 + 2 + 2 = 3 + 3； 2 * 2 * 2 < 3 * 3;因此取越多的3越好。

算法实践
```
function getLargetLength(n){
    if(n === 1) return 1;
    if(n === 2) return 2;
    if(n === 3) return 3;
    return 3 * getlargetLength(n - 3);
}
```
还有一种思路是  
(x+y)² >= 4xy  仅当  x = y  的时候取等号。  因此这个题可以转化为 把生成尽量均分两段，均分之后再均分，直至只剩2 和 3；这时候的乘积最大。 

【背包问题】

给定N个物品和一个容量为C的背包,物品i的重量为Wi，其价值为Vi，背包问题是如何选择装入背包的物品，使得装入背包中物品的总价值最大。注意在背包问题中，可以将某种物品的一部分装入背包中，但是不可以重复装入。

思路： 可以将某种物品的一部分装入背包 >>>  物品可以被分割  >>> 尽量装单位价值大的东西

算法实践： 
```
/**
*  {array} good 物品列表 [w, v] w物体体积 ， v物品总价值
*  {number} c  背包容量
*  {number} maxValue 最大容量
**/

// 假设物品列表已按重量单位降序排列

function greedy_knapSack(good, c){
    let w = 0;
    let maxValue = 0;
    for(let i = 0; good[i][0] <= c; i++){
        maxValue += good[i][1];
        c = c - good[i][0];
    }
    // 如果正好装完 直接返回
    if(c === 0 ){
        return maxValue
    }
    // 将超出背包剩余体积的物品进行分割
    let perV = good[i][1]  / good[i][0];
    maxValue += c * perV;
    return maxValue    
}
```

**【均分纸牌】**

均分纸牌问题：有 N 堆纸牌，编号分别为 1，2，…, N。每堆上有若干张，但纸牌总数必为 N 的倍数。可以在任一堆上取若于张纸牌，然后移动。
 　　移牌规则为：在编号为 1 堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 N 的堆上取的纸牌，只能移到编号为 N-1 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

 　　现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

 　　例如 N=4，4 堆纸牌数分别为：

 　　①　9　②　8　③　17　④　6

 　　移动3次可达到目的：

 　　从 ③ 取 4 张牌放到 ④ （9 8 13 10） -> 从 ③ 取 3 张牌放到 ②（9 11 10 10）-> 从 ② 取 1 张牌放到①（10 10 10 10）。

[思路](https://blog.csdn.net/u011035622/article/details/43650869)

算法实践

```
/**
* {array} arr 纸牌数组
**/
 function getMoveCardTime(arr){
      let sum  = arr.reduce((total, e)=>{
          return total + e;
      }, 0) / arr.length;
            
      let len = arr.length - 1 ;
      let time  = 0;
      for(var i = 0; i < len; i++){
         if(arr[i] < sum || arr[i] > sum){
              arr[i+1] =  arr[i+1] + sum - arr[i];
              time++;
         }
      }
       return time;
}
```

**【最大整数】**
设有n个正整数，将它们连接成一排，组成一个最大的多位整数。
解题思路： 先把整数转换成字符串，然后在比较a+b和b+a，如果a+b>=b+a，就把a排在b的前面，反之则把a排在b的后面。
算法实践
```
/**
* {array} arr放置正整数的数组
* { string } str 返回值
**/
function getMax(arr){
     arr.sort((a, b)=>{
        return ( String(b) + String(a) ) - ( String(a) + String(b) )
     });
     return arr.join('');
}
```


**【会场分配】**

假设要在足够多的会场里安排一批数目为N活动，E={e1, e2, …, en}，其中每个活动都需要使用某一会场，而在同一时间内该会场只能由一个活动使用，每个活动都有开始时间si和结束时间fi(si<fi)，并希望使用尽可能少的会场。设计一个有效的贪心算法进行安排。

思路： 将活动按结束时间从小到大排序， 安排好第一个之后，再按合适的排布顺序安排接下来的活动
```
/**
* {array}  待排活动  {si, fi}
* {number}  totalTime 会场可供使用的时间
* { number } n 返回的最多可排列次数
**/
        
  function getTimes(arr, totalTime){
      let N = 1;
      arr.sort((a, b) =>{
           return a.fi- b.fi;
       });
      let currentAcurrentActive = arr[0];
      for(var i = 1; i < arr.length; i++ ){
          if(currentAcurrentActive.fi< arr[i].fi && arr[i].fi<= totalTime){
              N += 1;
              currentAcurrentActive = arr[i];
          }
       }
       return N;
 }
        
```

**【删除问题】**

给定n位正整数a，去掉其中任意k个数字后，剩下的数字按原次序排列组成一个新的正整数。对于给定的n和k，设计一个算法，找出剩下数字组成的新数最大的删数方案。
输入示例： 178543
输出： 7854

思路： 最优解是删除出现的第一个左边>右边的数，因为删除之后高位减小。
算法实践：
```
/**
* @desc 先扫描 每次删除一位 然后再进行重新删除  
* {number} s 传入数字
* {number}  k  要删除的位数
  **/
function getMax(s, k){
      if(k === 0) return s;
      let str = String(s);
      if(k === str.length)  return 0;

      while(k > 0){
           let flag = false; // 此次循环是否进行删除操作，如果没有删除，说明已经从大到小排列，直接删除最后几位
           let arr = str.split('');
           let t = 0;  //记录上次筛选停止的位置
           for(let i = t; i < arr.length - 1; i++ ){ // 每次只删除一次
                if(arr[i] < arr[i+1]){
                   arr.splice(i, 1);
                   flag = true;
                   t = i;
                   k--;
                   break;
                }
           }
           if(!flag){
             return Number( arr.slice(0, -1).join('') );
           }
           str = arr.join('');
       }
       return Number(str);
}
```


**【最优服务次序问题】**
设有n个顾客同时等待一项服务，顾客i所需要的服务时间为ti，应如何安排顾客的服务次序，才能使平均等待时间最短？平均等待时间是n个顾客等待服务时间的总和除以n。
测试用例：
10（顾客数）
56 12 1 99 1000 234 33 55 99 812（所有顾客的服务时间）
输出：
532（最小平均等待时间）

思路： 服务时间短的优先服务

算法实践
```
/**
* {array} arr 输入的待排列数组
**/
function getMinTime(arr){
      arr.sort((a, b)=>{
         return a - b;
      });
      let time = 0;
      arr.reduce((total, e, index)=>{
            time += total;
            return total + e;
      }, 0);
      return time;
}
```


【最小生成树】


PS 贪心法证明步骤
1. 叙述一个有关自然数n的命题，该命题判断该贪心策略的执行最终将导致最优解，其中自然数n可以代表算法步数的问题规模
2.证明命题对所有的自然数为真
    归纳基础（从最小的实例开始）
    归纳步骤（第一或者第二数学归纳法）

可以再有限步将任意一个普通最优解逐步转化为算法的最优解
