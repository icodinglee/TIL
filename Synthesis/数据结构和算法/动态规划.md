#### **基本概念**
 动态规划的过程是： 每次决策依赖于当前的状态，又随即引起状态转移。一个决策的序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就成为动态规划。

#### 基本思想与策略
 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题，按顺序求解子阶段。前一个子问题的解，为后一个子问题的求解提供了有用的信息。在求解任一个子问题的时候，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依此解决子问题，最后一个子问题就是初始问题的解。

 由于动态规划的问题多数有重叠子问题的这个特点，为了减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组里。
 
与分治法最大的区别：适合于用动态规划求解的问题，经分解得到的子问题往往不是相互都独立的（即下一个阶段的求解是建立在上一个子阶段的解的基础上，进行进一步求解）。

#### **适用的情况**

**能采用动态规划求解的问题一般都要具有3个性质：**

1.最优化原理： 如果问题的最优解包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
2.无后效性： 即某个阶段一旦确定，就不受这个状态以后决策的影响。也就说，某状态以后的过程不会影响之前的状态，只与当前状态有关。
3.有重叠子问题：即子问题之间是不独立的，一个子问题在下一个阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

#### **求解的基本步骤**

动态规划所处理的问题是一个多阶段决策问题，一般是由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线）。

*** 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 ***

1.划分阶段： 按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
2.确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
3.确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可以写出。但事实常常反过来，根据相邻两个阶段的状态之间的关系来去欸但那个决策方法和状态转移方程。
4.寻找边界条件。给出的状态转移方程是一个递推式，需要一个递推的截至条件或边界条件。

一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程。

实际应用中可以按以下几个简化的步骤进行设计：
1. 分析最优解的性质，并刻画其结构特征。
2. 递归的定义最优解。
3. 以自底向上或自定向下的记忆方式（备忘录法）计算出最优值。
4. 根据计算最优值时得到的信息，构造问题的最优解。

#### **算法实现的说明**
使用动态规划求解问题，最重要的就是确定动态规划三要素：
1.问题的阶段
2.每个阶段的状态
3.从前一个阶段转化到后一个阶段的递推关系。

递推关系必须是从次小的问题开始到较大的问题之间的转换，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。
确定了动态规划的这三要素，整个求解过程就可以用一个最优决策来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题的状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态的最优值，填表的过程就是根据递推关系，从一行一列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

*** f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} ***

> >

#### **案例分析**

【爬楼梯】有N阶楼梯 ，你每次只能爬1或2 阶 楼梯；能有多少种方法；

分析可知： 最后到达n阶台阶时候，最后一步可以是爬两阶或者一阶，因为问题可以转化为 T(N) = T(N-1) + T(N-2),其中 N > 2;

| 0          | 1       |  2      | 3     | 4     |
| --------   | -----:  | :----:  | :----:| :----:|
| 0          | 1       |   2     |   3   |   5   |     

** 算法实践 **
```
function climbStair(n){
    if(n==0||n==1){
       return 1;
    }
    var arr = [];  // 将计算后的值放在一个数组里，减少递归次数
    arr[0]=1;
    arr[1]=2;
    for(int i=2;i<n;i++){
       arr[i]=arr[i-1]+arr[i-2];
    }
    return arr[n-1];
}
```  

【0-1背包问题】有N件物品和一个容量为W的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。
算法实践
```
 function knapsack(weights, values, W){
      var n = weights.length;
      var f = new Array(n);
      f[-1] = new Array(W+1).fill(0);
      for(var i = 0 ; i < n ; i++){ //注意边界，没有等号
            f[i] = new Array(W).fill(0)
            for(var j=0; j<=W; j++){//注意边界，有等号
              if( j < weights[i] ){ //注意边界， 没有等号
                  f[i][j] = f[i-1][j]
              }else{
                  f[i][j] = Math.max(f[i-1][j], f[i-1][j-weights[i]] + values[i] );//case 3
               }
            }
       }
       return f[n-1][W]
  }
```

【最长公共字符串】 给出两个字符串a, b，求它们的最长、连续的公共字串。

算法实践
```
 function getLCS(X, Y){
      var LCS = (n, m) => {
           if(m === 0 || n === 0){
            　　return 0;
           }
           if(X[n - 1] === Y[m - 1]){
            　　return LCS(n-1, m-1) + 1;
           }else{
            　　return Math.max( LCS(n, m-1), LCS(n-1, m) );
           }
       }
            
      return LCS(X.length, Y.length);
}

```
